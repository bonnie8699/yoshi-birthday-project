<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Yoshi's Cave Dash</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #0f0518; /* Very Dark Purple Border */
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }
      #root { 
          width: 100%; 
          height: 100%; 
          display: flex;
          justify-content: center;
          align-items: center;
      }
      .font-retro { font-family: 'Courier New', Courier, monospace; }
      
      /* Force the canvas to maintain 4:3 Aspect Ratio and fit within viewport */
      canvas {
          background-color: #1a0b2e; /* Cave Background */
          image-rendering: pixelated;
          width: min(100vw, 133.33vh);
          height: min(100vh, 75vw);
          box-shadow: 0 0 30px rgba(168, 85, 247, 0.3); /* Purple glow */
      }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- MAIN GAME SCRIPT -->
    <script type="text/babel" data-presets="typescript,react">
        const { useState, useEffect, useRef, useCallback } = React;

        // ==========================================
        // 1. CONSTANTS
        // ==========================================
        const SCREEN_WIDTH = 320;
        const SCREEN_HEIGHT = 240;
        
        // Physics
        const GRAVITY = 800;
        const JUMP_FORCE = -240;
        const GAME_SPEED = 100; // Pixels per second
        const PIPE_SPAWN_RATE = 1.8; // Seconds
        const PIPE_GAP = 75; // Increased gap for easier difficulty (was 55)
        
        const COLORS = {
            BG: '#1a0b2e',
            BG_ACCENT: '#2e1a47',
            LAVA_TOP: '#ff9f43',
            LAVA_BODY: '#ee5253',
            LAVA_DARK: '#b33939',
            PIPE_LIGHT: '#55efc4',
            PIPE_DARK: '#00b894',
            PIPE_SHADOW: '#006266',
            CRYSTAL: '#d580ff',
            CRYSTAL_DARK: '#8e44ad',
            TEXT: '#ffffff',
            UI_BG: 'rgba(0, 0, 0, 0.6)'
        };

        const PAL = {
            _: null,
            W: '#ffffff', // White
            K: '#000000', // Black
            G: '#00b894', // Green (Yoshi)
            L: '#55efc4', // Light Green
            R: '#ff6b6b', // Red (Shoes)
            O: '#feca57', // Orange
            Y: '#ffff99', // Yellow
            X: '#636e72', // Grey (Propeller)
        };

        // ==========================================
        // 2. ASSETS
        // ==========================================
        
        // Yoshi in Airplane Mode (Side View)
        const YOSHI_PLANE = [
            "________X_______",
            "_______X_X______",
            "________X_______",
            "____GGGGGGG_____",
            "___GGGGGGGGGG___",
            "__GWWGGGGGGGGG__",
            "__GWWGGGGGGGGG__",
            "__GGGGGGWWWWG___",
            "___GGGGGGWWWG___",
            "___ORRGGGGGG____",
            "___ORR___RR_____",
        ];

        const COIN_SPRITE = [
            "__YYYY__",
            "_YWOOYY_",
            "_YOOOYY_",
            "_YOOOYY_",
            "_YWOOYY_",
            "__YYYY__",
        ];
        
        const CRYSTAL_SPRITE = [
            "____C____",
            "___CDC___",
            "___CDC___",
            "__CDDDC__",
            "__CDDDC__",
            "_CDDDDDC_",
            "__CDDDC__",
            "___CDC___",
        ];

        // ==========================================
        // 3. AUDIO ENGINE
        // ==========================================
        class AudioEngine {
            constructor() { this.ctx = null; }
            getContext() {
                if (!this.ctx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (AC) this.ctx = new AC();
                }
                return this.ctx;
            }
            playJump() {
                const ctx = this.getContext();
                if (!ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(300, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            }
            playCoin() {
                const ctx = this.getContext();
                if (!ctx) return;
                const now = ctx.currentTime;
                const o1 = ctx.createOscillator();
                const g1 = ctx.createGain();
                o1.type = 'sine';
                o1.frequency.setValueAtTime(1200, now);
                g1.gain.setValueAtTime(0.1, now);
                g1.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                o1.connect(g1); g1.connect(ctx.destination);
                o1.start(); o1.stop(now + 0.1);
                
                const o2 = ctx.createOscillator();
                const g2 = ctx.createGain();
                o2.type = 'sine';
                o2.frequency.setValueAtTime(1800, now + 0.05);
                g2.gain.setValueAtTime(0.1, now + 0.05);
                g2.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                o2.connect(g2); g2.connect(ctx.destination);
                o2.start(now + 0.05); o2.stop(now + 0.15);
            }
            playCrash() {
                const ctx = this.getContext();
                if (!ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, ctx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.3);
            }
        }
        const audio = new AudioEngine();

        // ==========================================
        // 4. MAIN GAME COMPONENT
        // ==========================================
        const App = () => {
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const previousTimeRef = useRef();
            
            // Game State Refs (Mutable for loop)
            const playerRef = useRef({ 
                x: 40, y: SCREEN_HEIGHT / 2, 
                vy: 0, 
                w: 24, h: 18, 
                rotation: 0 
            });
            const pipesRef = useRef([]);
            const coinsRef = useRef([]);
            const particlesRef = useRef([]);
            const scoreRef = useRef(0);
            const gameTimeRef = useRef(0);
            const spawnTimerRef = useRef(0);
            const bgOffsetRef = useRef(0);
            
            const [gameState, setGameState] = useState('START'); // START, PLAYING, GAMEOVER

            // --- Game Logic ---
            const resetGame = () => {
                playerRef.current = { x: 40, y: SCREEN_HEIGHT / 2, vy: 0, w: 24, h: 18, rotation: 0 };
                pipesRef.current = [];
                coinsRef.current = [];
                particlesRef.current = [];
                scoreRef.current = 0;
                gameTimeRef.current = 0;
                spawnTimerRef.current = 0;
                bgOffsetRef.current = 0;
                setGameState('PLAYING');
            };

            const jump = () => {
                if (gameState === 'PLAYING') {
                    playerRef.current.vy = JUMP_FORCE;
                    audio.playJump();
                    // Spawn little smoke particles
                    for(let i=0; i<3; i++) {
                        particlesRef.current.push({
                            x: playerRef.current.x,
                            y: playerRef.current.y + 10,
                            vx: -20 - Math.random()*20,
                            vy: Math.random()*20 - 10,
                            life: 0.5,
                            color: '#fff'
                        });
                    }
                }
            };

            const spawnPipe = () => {
                const minH = 40;
                const maxH = SCREEN_HEIGHT - PIPE_GAP - minH - 30; // 30 is ground buffer
                const topHeight = Math.floor(Math.random() * (maxH - minH) + minH);
                
                const pipeX = SCREEN_WIDTH + 20;
                pipesRef.current.push({
                    x: pipeX,
                    topH: topHeight,
                    w: 26,
                    passed: false
                });

                // Chance to spawn coin in the gap
                if (Math.random() > 0.3) {
                    coinsRef.current.push({
                        x: pipeX + 13 - 6, // Centered in pipe
                        y: topHeight + PIPE_GAP / 2 - 6,
                        w: 12, h: 12,
                        active: true
                    });
                }
            };

            const update = (dt) => {
                const player = playerRef.current;
                gameTimeRef.current += dt;
                bgOffsetRef.current += GAME_SPEED * dt * 0.5;

                // 1. Player Physics
                player.vy += GRAVITY * dt;
                player.y += player.vy * dt;
                
                // Rotation based on velocity
                player.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (player.vy * 0.1) * Math.PI / 180));

                // 2. Obstacles Spawning
                spawnTimerRef.current += dt;
                if (spawnTimerRef.current >= PIPE_SPAWN_RATE) {
                    spawnPipe();
                    spawnTimerRef.current = 0;
                }

                // 3. Move Entities
                pipesRef.current.forEach(p => p.x -= GAME_SPEED * dt);
                coinsRef.current.forEach(c => c.x -= GAME_SPEED * dt);
                
                // 4. Collision & Cleanup
                const playerRect = { 
                    l: player.x + 4, r: player.x + player.w - 4, 
                    t: player.y + 4, b: player.y + player.h - 2 
                };

                // Ceiling: Clamp position, do not kill
                if (player.y < 0) {
                    player.y = 0;
                    player.vy = 0; // Reset velocity so they don't get "stuck" with high negative velocity
                }

                // Ground (Lava): Kill
                if (player.y + player.h > SCREEN_HEIGHT - 20) {
                    die();
                }

                // Pipes
                pipesRef.current.forEach(p => {
                    const pipeL = p.x;
                    const pipeR = p.x + p.w;
                    
                    // Top Pipe
                    if (playerRect.r > pipeL && playerRect.l < pipeR && playerRect.t < p.topH) {
                        die();
                    }
                    // Bottom Pipe
                    if (playerRect.r > pipeL && playerRect.l < pipeR && playerRect.b > p.topH + PIPE_GAP) {
                        die();
                    }

                    // Score passing
                    if (!p.passed && playerRect.l > pipeR) {
                        p.passed = true;
                        scoreRef.current += 1;
                    }
                });

                // Coins
                coinsRef.current.forEach(c => {
                    if (c.active) {
                        if (playerRect.r > c.x && playerRect.l < c.x + c.w &&
                            playerRect.b > c.y && playerRect.t < c.y + c.h) {
                            c.active = false;
                            scoreRef.current += 5;
                            audio.playCoin();
                        }
                    }
                });

                // Clean up off-screen
                pipesRef.current = pipesRef.current.filter(p => p.x > -50);
                coinsRef.current = coinsRef.current.filter(c => c.x > -50);

                // Particles
                particlesRef.current.forEach(p => {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt;
                });
                particlesRef.current = particlesRef.current.filter(p => p.life > 0);
            };

            const die = () => {
                audio.playCrash();
                setGameState('GAMEOVER');
            };

            // --- Input ---
            const handleInput = useCallback((e) => {
                if (gameState === 'START' || gameState === 'GAMEOVER') {
                    // Simple debounce
                    if (gameState === 'GAMEOVER' && Date.now() - lastStateTime.current < 500) return;
                    resetGame();
                } else if (gameState === 'PLAYING') {
                    jump();
                }
            }, [gameState]);

            const lastStateTime = useRef(0);
            useEffect(() => {
                lastStateTime.current = Date.now();
            }, [gameState]);
            
            // Keyboard support
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.code === 'Space' || e.code === 'ArrowUp') {
                        handleInput();
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleInput]);

            // --- Rendering ---
            const drawSprite = (ctx, sprite, x, y, scale = 1, rotation = 0, paletteOverride = null) => {
                if (!sprite || sprite.length === 0) return;
                ctx.save();
                // Translate to center for rotation
                const w = sprite[0].length * scale;
                const h = sprite.length * scale;
                const cx = x + w/2;
                const cy = y + h/2;
                ctx.translate(cx, cy);
                ctx.rotate(rotation);
                ctx.translate(-cx, -cy);

                for (let row = 0; row < sprite.length; row++) {
                    for (let col = 0; col < sprite[0].length; col++) {
                        const char = sprite[row][col];
                        const color = (paletteOverride && paletteOverride[char]) ? paletteOverride[char] : PAL[char];
                        if (color) {
                            ctx.fillStyle = color;
                            ctx.fillRect(Math.floor(x + col * scale), Math.floor(y + row * scale), Math.ceil(scale), Math.ceil(scale));
                        }
                    }
                }
                ctx.restore();
            };

            const drawBackground = (ctx) => {
                // Background Color
                ctx.fillStyle = COLORS.BG;
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                // Distant Crystals (Parallax slow)
                const offset = (bgOffsetRef.current * 0.2) % SCREEN_WIDTH;
                const crystalPattern = [50, 120, 200, 280];
                crystalPattern.forEach(xBase => {
                    let x = xBase - offset;
                    if (x < -20) x += SCREEN_WIDTH + 40;
                    
                    // Override palette to draw crystal
                    const crystalPal = {...PAL, C: COLORS.CRYSTAL, D: COLORS.CRYSTAL_DARK};
                    drawSprite(ctx, CRYSTAL_SPRITE, x, 50, 2, 0, crystalPal);
                    // Reflection in "distance"
                    drawSprite(ctx, CRYSTAL_SPRITE, x + 30, 150, 1.5, 0, crystalPal);
                });

                // Cave Roof (Stalactites)
                ctx.fillStyle = COLORS.BG_ACCENT;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                for(let i=0; i<=SCREEN_WIDTH; i+=20) {
                    ctx.lineTo(i, 10 + Math.random()*15); // jittery roof
                }
                ctx.lineTo(SCREEN_WIDTH, 0);
                ctx.fill();

                // Lava Floor
                const lavaY = SCREEN_HEIGHT - 20;
                
                // Lava Glow
                const grad = ctx.createLinearGradient(0, lavaY - 10, 0, SCREEN_HEIGHT);
                grad.addColorStop(0, 'rgba(255, 100, 0, 0)');
                grad.addColorStop(1, 'rgba(255, 100, 0, 0.5)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, lavaY - 20, SCREEN_WIDTH, 20);

                // Moving Lava
                const lavaOffset = (gameTimeRef.current * 20) % 20;
                ctx.fillStyle = COLORS.LAVA_BODY;
                ctx.fillRect(0, lavaY, SCREEN_WIDTH, 20);
                
                ctx.fillStyle = COLORS.LAVA_TOP;
                for(let i=-20; i<SCREEN_WIDTH; i+=20) {
                    // Wavy lava top
                    ctx.beginPath();
                    ctx.arc(i + lavaOffset, lavaY, 15, Math.PI, 0);
                    ctx.fill();
                }
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                drawBackground(ctx);

                // Pipes
                pipesRef.current.forEach(p => {
                    // Pipe Body Color
                    ctx.fillStyle = COLORS.PIPE_DARK;
                    
                    // Top Pipe
                    ctx.fillRect(p.x + 2, 0, p.w - 4, p.topH); // Body
                    ctx.fillStyle = COLORS.PIPE_LIGHT; // Highlight
                    ctx.fillRect(p.x + 4, 0, 4, p.topH);
                    
                    // Top Cap
                    ctx.fillStyle = COLORS.PIPE_DARK;
                    ctx.fillRect(p.x, p.topH - 12, p.w, 12);
                    ctx.fillStyle = COLORS.PIPE_SHADOW; // Rim
                    ctx.fillRect(p.x, p.topH - 2, p.w, 2);


                    // Bottom Pipe
                    const bottomY = p.topH + PIPE_GAP;
                    const bottomH = SCREEN_HEIGHT - bottomY;
                    
                    ctx.fillStyle = COLORS.PIPE_DARK;
                    ctx.fillRect(p.x + 2, bottomY, p.w - 4, bottomH);
                    ctx.fillStyle = COLORS.PIPE_LIGHT;
                    ctx.fillRect(p.x + 4, bottomY, 4, bottomH);

                    // Bottom Cap
                    ctx.fillStyle = COLORS.PIPE_DARK;
                    ctx.fillRect(p.x, bottomY, p.w, 12);
                    ctx.fillStyle = COLORS.PIPE_SHADOW; // Rim
                    ctx.fillRect(p.x, bottomY, p.w, 2);
                });

                // Coins
                coinsRef.current.forEach(c => {
                    if (c.active) {
                        // Bobbing animation
                        const bob = Math.sin(gameTimeRef.current * 5) * 3;
                        drawSprite(ctx, COIN_SPRITE, c.x, c.y + bob, 2);
                    }
                });

                // Player
                const p = playerRef.current;
                // Propeller Spin Animation
                let sprite = [...YOSHI_PLANE]; // Copy
                if (Math.floor(gameTimeRef.current * 20) % 2 === 0) {
                    // Simple sprite swap for animation could go here, 
                    // for now just shift color or pixel slightly if needed.
                }
                drawSprite(ctx, sprite, p.x, p.y, 1.5, p.rotation);

                // Particles
                particlesRef.current.forEach(part => {
                    ctx.fillStyle = part.color;
                    ctx.globalAlpha = part.life;
                    ctx.fillRect(part.x, part.y, 3, 3);
                    ctx.globalAlpha = 1.0;
                });

                // UI
                if (gameState === 'PLAYING') {
                    ctx.fillStyle = COLORS.UI_BG;
                    ctx.beginPath();
                    ctx.roundRect(10, 10, 100, 30, 8);
                    ctx.fill();
                    ctx.fillStyle = COLORS.TEXT;
                    ctx.font = 'bold 20px "Courier New"';
                    ctx.fillText(`SCORE: ${scoreRef.current}`, 20, 32);
                } else {
                    // Overlay
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    
                    ctx.textAlign = 'center';
                    if (gameState === 'START') {
                        ctx.fillStyle = COLORS.CRYSTAL;
                        ctx.font = 'bold 24px "Courier New"';
                        ctx.fillText("CAVE DASH", SCREEN_WIDTH/2, SCREEN_HEIGHT/2 - 20);
                        
                        ctx.fillStyle = '#fff';
                        ctx.font = '12px "Courier New"';
                        ctx.fillText("Tap / Space to Fly", SCREEN_WIDTH/2, SCREEN_HEIGHT/2 + 10);
                        ctx.fillStyle = COLORS.LAVA_TOP;
                        ctx.fillText("Dodge pipes & lava!", SCREEN_WIDTH/2, SCREEN_HEIGHT/2 + 30);
                    } else if (gameState === 'GAMEOVER') {
                        ctx.fillStyle = '#ff6b6b';
                        ctx.font = 'bold 24px "Courier New"';
                        ctx.fillText("CRASHED!", SCREEN_WIDTH/2, SCREEN_HEIGHT/2 - 10);
                        
                        ctx.fillStyle = '#fff';
                        ctx.font = '16px "Courier New"';
                        ctx.fillText(`Final Score: ${scoreRef.current}`, SCREEN_WIDTH/2, SCREEN_HEIGHT/2 + 15);
                        
                        ctx.font = '12px "Courier New"';
                        ctx.fillText("Tap to Retry", SCREEN_WIDTH/2, SCREEN_HEIGHT/2 + 40);
                    }
                    ctx.textAlign = 'left'; // Reset
                }
            };

            const animate = (time) => {
                if (previousTimeRef.current !== undefined) {
                    const dt = Math.min((time - previousTimeRef.current) / 1000, 0.05);
                    if (gameState === 'PLAYING') update(dt);
                }
                draw();
                previousTimeRef.current = time;
                requestRef.current = requestAnimationFrame(animate);
            };

            useEffect(() => {
                requestRef.current = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(requestRef.current);
            }, [gameState]);

            return (
                <canvas 
                    ref={canvasRef} 
                    width={SCREEN_WIDTH} 
                    height={SCREEN_HEIGHT} 
                    onPointerDown={handleInput}
                />
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>