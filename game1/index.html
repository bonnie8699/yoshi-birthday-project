<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Yoshi's Pixel Engine - Single File Edition</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone (for compiling TSX in browser) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      /* Global reset for full screen game feel */
      html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden; /* Prevent scrolling */
        background-color: #000000;
        touch-action: none; /* Critical: Disables browser gestures like pull-to-refresh */
        user-select: none; /* Prevent text selection */
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }
      
      #root {
        width: 100%;
        height: 100%;
      }

      /* Custom font logic */
      .font-retro {
        font-family: 'Courier New', Courier, monospace;
      }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- MAIN GAME SCRIPT -->
    <script type="text/babel" data-presets="typescript,react">
        const { useState, useEffect, useRef, useCallback } = React;

        // ==========================================
        // 1. CONSTANTS & CONFIG
        // ==========================================
        const SCREEN_WIDTH = 320;
        const SCREEN_HEIGHT = 240;
        const GRAVITY = 900;
        const JUMP_FORCE = -340; 
        const MOVE_SPEED = 140;

        const COLORS = {
            YOSHI: '#4ade80',
            SKY: '#63adff',
            GRID: 'rgba(0,0,0,0.15)',
            TEXT: '#ffffff',
            
            // Palette Keys
            P_TRANSPARENT: null,
            P_WHITE: '#ffffff',
            P_BLACK: '#000000',
            
            // Environment
            P_GROUND_FACE: '#d88046',
            P_GROUND_BORDER: '#8b4513',
            P_BRICK_FACE: '#b86f2b', 
            P_Q_GOLD: '#fcbc00',
            
            // Entities
            CAKE_BASE: '#ec4899',
            CAKE_TOP: '#fce7f3',
            GOOMBA: '#92400e',
        };

        const PAL = {
            _: null,
            W: '#ffffff',
            K: '#000000',
            G: '#1fa400',
            L: '#67e723',
            R: '#d31616',
            O: '#f78f1e',
            Y: '#fcd303',
            B: '#9c4a00',
            T: '#d67f2b',
            P: '#00a000',
            S: '#48d300',
            Z: '#005c00' 
        };

        // ==========================================
        // 2. ASSETS (SPRITES)
        // ==========================================
        const YOSHI_SPRITE = [
            "____GGGGG_______",
            "___GWWWWG_______",
            "___GWWWWG_______",
            "__GWWWWGGGG____",
            "__GWWGGGGGGG____",
            "__GWWGGGGGGG____",
            "__GGGGGGGGGRR___",
            "__GGGGGGGGGRR___",
            "___GGGGGGGGG____",
            "___GGGGGGGGG____",
            "__GGGGGGW_______",
            "__OGGGGGW_______",
            "__OGGGGW________",
            "__OOO___________",
            "__OOOOO_________",
            "__OO_OO_________",
        ];

        const GROUND_SPRITE = [
            "BBBBBBBBBBBBBBBB",
            "BTTTTTTTTTTTTTTB",
            "BTTTTTTTTTTTTTTB",
            "BTTTTTTTTTTTTTTB",
            "BTTTTBBBBBBTTTTB",
            "BTTTTBBBBBBTTTTB",
            "BTTTTTTTTTTTTTTB",
            "BTTTTTTTTTTTTTTB",
            "BTTTTTTTTTTTTTTB",
            "BTTTTBBBBBBTTTTB",
            "BTTTTBBBBBBTTTTB",
            "BTTTTTTTTTTTTTTB",
            "BTTTTTTTTTTTTTTB",
            "BTTTTTTTTTTTTTTB",
            "BTTTTTTTTTTTTTTB",
            "BBBBBBBBBBBBBBBB",
        ];

        const BRICK_SPRITE = [
            "BBBBBBBBBBBBBBBB",
            "BTTTTBTTTTBTTTTB",
            "BTTTTBTTTTBTTTTB",
            "BBBBBBBBBBBBBBBB",
            "BTTTTBTTTTBTTTTB",
            "BTTTTBTTTTBTTTTB",
            "BBBBBBBBBBBBBBBB",
            "BTTTTBTTTTBTTTTB",
            "BTTTTBTTTTBTTTTB",
            "BBBBBBBBBBBBBBBB",
            "BTTTTBTTTTBTTTTB",
            "BTTTTBTTTTBTTTTB",
            "BBBBBBBBBBBBBBBB",
            "BTTTTBTTTTBTTTTB",
            "BTTTTBTTTTBTTTTB",
            "BBBBBBBBBBBBBBBB",
        ];

        const QBLOCK_SPRITE = [
            "BBBBBBBBBBBBBBBB",
            "BYYYYYYYYYYYYYYB",
            "BYYYKKKKKKKYYYYB",
            "BYYKKYKKKKYKKYYB",
            "BYYKKYKKKKYKKYYB",
            "BYYYYYKKKYYYYYYB",
            "BYYYYYKKKYYYYYYB",
            "BYYYYYKYYYYYYYYB",
            "BYYYYYKYYYYYYYYB",
            "BYYYYYYYYYYYYYYB",
            "BYYYYYKYYYYYYYYB",
            "BYYYYYKYYYYYYYYB",
            "BYYYYYYYYYYYYYYB",
            "BYYKKYYYYYYKKYYB",
            "BYYKKYYYYYYKKYYB",
            "BBBBBBBBBBBBBBBB",
        ];

        const PIPE_BODY_SPRITE = [
            "KPPPPPPPPPPPPPPK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KSSSSSSSPSSSSSZK",
            "KPPPPPPPPPPPPPPK",
        ];

        const BUSH_SPRITE = [
            "_______GGGG_______GGGG______",
            "_____GGLLLLGG___GGLLLLGG____",
            "____GLLLLLLLLGGGLLLLLLLLG___",
            "___GLLLLLLLLLLGLLLLLLLLLLG__",
            "__GLLLLLLLLLLLLLLLLLLLLLLLG_",
            "__GLLLLLLLLLLLLLLLLLLLLLLLG_",
            "_GLLLLLLLLLLLLLLLLLLLLLLLLLG",
            "_GLLLLLLLLLLLLLLLLLLLLLLLLLG",
            "GLLLLLLLLLLLLLLLLLLLLLLLLLLG",
            "GLLLLLLLLLLLLLLLLLLLLLLLLLLG",
            "GLLLLLLLLLLLLLLLLLLLLLLLLLLG",
            "GLLLLLLLLLLLLLLLLLLLLLLLLLLG",
            "GLLLLLLLLLLLLLLLLLLLLLLLLLLG",
            "GLLLLLLLLLLLLLLLLLLLLLLLLLLG",
            "GGGGGGGGGGGGGGGGGGGGGGGGGGGG",
            "____________________________",
        ];

        const CLOUD_SPRITE = [
            "________WWWWWWWW________",
            "______WWWWWWWWWWWW______",
            "____WWWWWWWWWWWWWWWW____",
            "___WWWWWWWWWWWWWWWWWW___",
            "__WWWWWWWWWWWWWWWWWWWW__",
            "__WWWWWWWWWWWWWWWWWWWW__",
            "_WWWWWWWWWWWWWWWWWWWWWW_",
            "_WWWWWWWWWWWWWWWWWWWWWW_",
            "WWWWWWWWWWWWWWWWWWWWWWWW",
            "WWWWWWWWWWWWWWWWWWWWWWWW",
            "WWWWWWWWWWWWWWWWWWWWWWWW",
            "WWWWWWWWWWWWWWWWWWWWWWWW",
            "__WWWWWWWWWWWWWWWWWWWW__",
            "___WWWWWWWWWWWWWWWWWW___",
            "____WWWWWWWWWWWWWWWW____",
            "______WWWWWWWWWWWW______",
        ];

        const COIN_SPRITE = [
            "__BBBBBB__",
            "_BYYYYYYB_",
            "_BYYYYYYB_",
            "BYWYYYYYYB",
            "BYWYYYYYYB",
            "BYWYYYYYYB",
            "BYWYYYYYYB",
            "_BYYYYYYB_",
            "_BYYYYYYB_",
            "__BBBBBB__",
        ];

        // ==========================================
        // 3. AUDIO ENGINE
        // ==========================================
        class AudioEngine {
            constructor() {
                this.ctx = null;
            }

            getContext() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        this.ctx = new AudioContext();
                    }
                }
                return this.ctx;
            }

            playJump() {
                const ctx = this.getContext();
                if (!ctx) return;
                
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(300, ctx.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                osc.start();
                osc.stop(ctx.currentTime + 0.1);
            }

            playCollect() {
                const ctx = this.getContext();
                if (!ctx) return;
                
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, ctx.currentTime);
                osc.frequency.setValueAtTime(800, ctx.currentTime + 0.05);
                
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                osc.start();
                osc.stop(ctx.currentTime + 0.1);
            }

            playWin() {
                const ctx = this.getContext();
                if (!ctx) return;
                
                const notes = [523.25, 659.25, 783.99, 1046.50];
                const now = ctx.currentTime;
                
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.1, now + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.3);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.3);
                });
            }
        }
        const audio = new AudioEngine();

        // ==========================================
        // 4. INPUT MANAGER
        // ==========================================
        class InputManager {
            constructor() {
                this.state = {
                    up: false, down: false, left: false, right: false, a: false, b: false
                };
                this.bindKeyboard();
            }

            bindKeyboard() {
                window.addEventListener('keydown', (e) => this.handleKey(e, true));
                window.addEventListener('keyup', (e) => this.handleKey(e, false));
            }

            handleKey(e, isDown) {
                switch (e.key) {
                    case 'ArrowUp': case 'w': case 'W': this.state.up = isDown; break;
                    case 'ArrowDown': case 's': case 'S': this.state.down = isDown; break;
                    case 'ArrowLeft': case 'a': case 'A': this.state.left = isDown; break;
                    case 'ArrowRight': case 'd': case 'D': this.state.right = isDown; break;
                    case 'z': case 'Z': case 'j': case 'J': this.state.b = isDown; break;
                    case 'x': case 'X': case 'k': case 'K': this.state.a = isDown; break;
                }
            }

            setVirtualInput(key, active) {
                this.state[key] = active;
            }

            getState() {
                return { ...this.state };
            }
        }
        const inputManager = new InputManager();

        // ==========================================
        // 5. COMPONENT: VirtualPad
        // ==========================================
        const VirtualPad = () => {
            const handleTouch = useCallback((key, active) => {
                inputManager.setVirtualInput(key, active);
            }, []);

            const bindTouch = (key) => ({
                onTouchStart: (e) => { e.preventDefault(); handleTouch(key, true); },
                onTouchEnd: (e) => { e.preventDefault(); handleTouch(key, false); },
                onMouseDown: (e) => { e.preventDefault(); handleTouch(key, true); },
                onMouseUp: (e) => { e.preventDefault(); handleTouch(key, false); },
                onMouseLeave: (e) => { e.preventDefault(); handleTouch(key, false); },
            });

            return (
                <div className="absolute bottom-4 left-0 right-0 px-4 pb-2 select-none pointer-events-none flex justify-between items-end z-50">
                    {/* D-Pad */}
                    <div className="relative w-36 h-36 pointer-events-auto opacity-70">
                        <div className="absolute top-0 left-12 w-12 h-12 bg-gray-700 rounded-t-lg active:bg-gray-500 border-2 border-gray-600" {...bindTouch('up')}>
                            <div className="w-0 h-0 border-l-[8px] border-l-transparent border-r-[8px] border-r-transparent border-b-[12px] border-b-gray-400 absolute top-2 left-3"></div>
                        </div>
                        <div className="absolute bottom-0 left-12 w-12 h-12 bg-gray-700 rounded-b-lg active:bg-gray-500 border-2 border-gray-600" {...bindTouch('down')}>
                            <div className="w-0 h-0 border-l-[8px] border-l-transparent border-r-[8px] border-r-transparent border-t-[12px] border-t-gray-400 absolute bottom-2 left-3"></div>
                        </div>
                        <div className="absolute top-12 left-0 w-12 h-12 bg-gray-700 rounded-l-lg active:bg-gray-500 border-2 border-gray-600" {...bindTouch('left')}>
                            <div className="w-0 h-0 border-t-[8px] border-t-transparent border-b-[8px] border-b-transparent border-r-[12px] border-r-gray-400 absolute top-3 left-2"></div>
                        </div>
                        <div className="absolute top-12 right-0 w-12 h-12 bg-gray-700 rounded-r-lg active:bg-gray-500 border-2 border-gray-600" {...bindTouch('right')}>
                            <div className="w-0 h-0 border-t-[8px] border-t-transparent border-b-[8px] border-b-transparent border-l-[12px] border-l-gray-400 absolute top-3 right-2"></div>
                        </div>
                        <div className="absolute top-12 left-12 w-12 h-12 bg-gray-700"></div>
                    </div>

                    {/* Action Buttons */}
                    <div className="flex gap-6 mb-4 mr-2 pointer-events-auto opacity-70">
                        <div className="flex flex-col items-center gap-1 mt-8">
                            <button className="w-16 h-16 rounded-full bg-red-700 border-b-4 border-red-900 active:border-b-0 active:translate-y-1 active:bg-red-600 shadow-lg flex items-center justify-center" {...bindTouch('b')}>
                                <span className="text-white font-bold text-xl font-mono">B</span>
                            </button>
                        </div>
                        <div className="flex flex-col items-center gap-1 -mt-4">
                            <button className="w-16 h-16 rounded-full bg-green-700 border-b-4 border-green-900 active:border-b-0 active:translate-y-1 active:bg-green-600 shadow-lg flex items-center justify-center" {...bindTouch('a')}>
                                <span className="text-white font-bold text-xl font-mono">A</span>
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // ==========================================
        // 6. MAIN APP LOGIC
        // ==========================================
        const App = () => {
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const previousTimeRef = useRef();
            
            const [gameState, setGameState] = useState('START');

            const eggCount = useRef(0);
            const yoshi = useRef({ 
                x: 50, y: 180, w: 14, h: 16, 
                vx: 0, vy: 0, 
                grounded: false, 
                facingRight: true,
                jumpCount: 0,
                wasAPressed: false
            });
            const camera = useRef({ x: 0 });
            
            const platforms = useRef([]);
            const enemies = useRef([]);
            const eggs = useRef([]);
            const decorations = useRef([]);
            const cake = useRef({ x: 0, y: 0, w: 0, h: 0 });

            // --- Draw Helpers ---
            const drawSprite = (ctx, sprite, x, y, flipX = false, scale = 1) => {
                const h = sprite.length;
                if (h === 0) return;
                const w = sprite[0].length;
                
                ctx.save();
                if (flipX) {
                    ctx.translate(x + w * scale, y);
                    ctx.scale(-1, 1);
                    ctx.translate(0, 0); 
                } else {
                    ctx.translate(x, y);
                }

                for (let row = 0; row < h; row++) {
                    for (let col = 0; col < w; col++) {
                        const char = sprite[row][col];
                        const color = PAL[char];
                        if (color) {
                            ctx.fillStyle = color;
                            ctx.fillRect(col * scale, row * scale, scale, scale);
                        }
                    }
                }
                ctx.restore();
            };

            const drawTiledSprite = (ctx, sprite, x, y, w, h) => {
                const tileW = sprite[0].length;
                const tileH = sprite.length;
                for (let dy = 0; dy < h; dy += tileH) {
                    for (let dx = 0; dx < w; dx += tileW) {
                        const drawW = Math.min(tileW, w - dx);
                        const drawH = Math.min(tileH, h - dy);
                        if (drawW < tileW || drawH < tileH) {
                            ctx.save();
                            ctx.beginPath();
                            ctx.rect(x + dx, y + dy, drawW, drawH);
                            ctx.clip();
                            drawSprite(ctx, sprite, x + dx, y + dy);
                            ctx.restore();
                        } else {
                            drawSprite(ctx, sprite, x + dx, y + dy);
                        }
                    }
                }
            }

            const checkCollision = (r1, r2) => {
                return (
                    r1.x < r2.x + r2.w &&
                    r1.x + r1.w > r2.x &&
                    r1.y < r2.y + r2.h &&
                    r1.y + r1.h > r2.y
                );
            };

            const loadLevel = () => {
                eggCount.current = 0;
                yoshi.current = { 
                    x: 50, y: 100, w: 14, h: 16, 
                    vx: 0, vy: 0, 
                    grounded: false, facingRight: true, jumpCount: 0, wasAPressed: false
                };
                camera.current = { x: 0 };
                
                const groundY = SCREEN_HEIGHT - 32;

                platforms.current = [
                    { x: -50, y: groundY, w: 400, h: 32, type: 'GROUND' },
                    { x: 400, y: groundY, w: 300, h: 32, type: 'GROUND' },
                    { x: 750, y: groundY, w: 500, h: 32, type: 'GROUND' },
                    { x: 250, y: groundY - 50, w: 64, h: 16, type: 'BRICK' }, 
                    { x: 350, y: groundY - 90, w: 64, h: 16, type: 'BRICK' }, 
                    { x: 500, y: groundY - 130, w: 48, h: 16, type: 'QBLOCK' },
                    { x: 650, y: groundY - 60, w: 48, h: 16, type: 'BRICK' },
                    { x: 720, y: groundY - 30, w: 48, h: 16, type: 'BRICK' },
                ];

                enemies.current = [
                    { id: 1, x: 200, y: groundY - 16, w: 16, h: 16, dir: -1, originX: 200, patrolDist: 80 },
                    { id: 2, x: 500, y: groundY - 16, w: 16, h: 16, dir: 1, originX: 500, patrolDist: 100 },
                    { id: 3, x: 900, y: groundY - 16, w: 16, h: 16, dir: -1, originX: 900, patrolDist: 100 },
                    { id: 4, x: 1050, y: groundY - 16, w: 16, h: 16, dir: 1, originX: 1050, patrolDist: 60 },
                ];

                eggs.current = [
                    { id: 1, x: 270, y: groundY - 70, w: 12, h: 12, collected: false, frameOffset: 0 },
                    { id: 2, x: 375, y: groundY - 110, w: 12, h: 12, collected: false, frameOffset: 2 },
                    { id: 3, x: 515, y: groundY - 150, w: 12, h: 12, collected: false, frameOffset: 4 },
                    { id: 4, x: 665, y: groundY - 80, w: 12, h: 12, collected: false, frameOffset: 1 },
                    { id: 5, x: 950, y: groundY - 20, w: 12, h: 12, collected: false, frameOffset: 3 },
                ];

                decorations.current = [
                    { x: 20, y: groundY - 16, type: 'BUSH' },
                    { x: 150, y: groundY - 16, type: 'BUSH' },
                    { x: 450, y: groundY - 16, type: 'BUSH' },
                    { x: 800, y: groundY - 16, type: 'BUSH' },
                    { x: 50, y: 50, type: 'CLOUD' },
                    { x: 250, y: 30, type: 'CLOUD' },
                    { x: 550, y: 60, type: 'CLOUD' },
                    { x: 850, y: 40, type: 'CLOUD' },
                    { x: 1100, y: 20, type: 'CLOUD' },
                ];

                cake.current = { x: 1100, y: groundY - 48, w: 48, h: 48 };
                setGameState('PLAYING');
            };

            useEffect(() => { loadLevel(); }, []);

            const update = (dt) => {
                const input = inputManager.getState();
                const p = yoshi.current;

                if (input.left) { p.vx = -MOVE_SPEED; p.facingRight = false; } 
                else if (input.right) { p.vx = MOVE_SPEED; p.facingRight = true; } 
                else { p.vx = 0; }

                if (input.a && !p.wasAPressed) {
                    if (p.grounded || p.jumpCount < 2) {
                        p.vy = JUMP_FORCE;
                        p.grounded = false;
                        p.jumpCount++;
                        audio.playJump();
                    }
                }
                p.wasAPressed = input.a;
                p.vy += GRAVITY * dt;

                p.x += p.vx * dt;
                for (const plat of platforms.current) {
                    if (checkCollision({x: p.x, y: p.y, w: p.w, h: p.h}, plat)) {
                        if (p.vx > 0) p.x = plat.x - p.w;
                        else if (p.vx < 0) p.x = plat.x + plat.w;
                    }
                }

                p.y += p.vy * dt;
                p.grounded = false;
                for (const plat of platforms.current) {
                    if (checkCollision({x: p.x, y: p.y, w: p.w, h: p.h}, plat)) {
                        if (p.vy > 0) {
                            p.y = plat.y - p.h; p.grounded = true; p.vy = 0; p.jumpCount = 0;
                        } else if (p.vy < 0) {
                            p.y = plat.y + plat.h; p.vy = 0;
                        }
                    }
                }

                if (p.y > SCREEN_HEIGHT + 50) setGameState('GAMEOVER');

                let targetCamX = p.x - SCREEN_WIDTH / 2 + p.w / 2;
                if (targetCamX < 0) targetCamX = 0;
                camera.current.x += (targetCamX - camera.current.x) * 10 * dt;

                enemies.current.forEach(e => {
                    e.x += 40 * e.dir * dt;
                    if (Math.abs(e.x - e.originX) > e.patrolDist) e.dir *= -1;
                    const playerHitbox = { x: p.x + 2, y: p.y, w: p.w - 4, h: p.h };
                    if (e.y < SCREEN_HEIGHT && checkCollision(playerHitbox, e)) {
                        if (p.vy > 0 && (p.y + p.h) < (e.y + e.h * 0.8)) {
                            e.y = 1000; p.vy = -200; p.jumpCount = 1; audio.playJump();
                        } else {
                            setGameState('GAMEOVER');
                        }
                    }
                });

                eggs.current.forEach(e => {
                    e.frameOffset += dt * 5; 
                    if (!e.collected && checkCollision({x: p.x, y: p.y, w: p.w, h: p.h}, e)) {
                        e.collected = true; eggCount.current++; audio.playCollect();
                    }
                });

                if (eggCount.current >= 5) {
                    setGameState('WIN');
                    audio.playWin();
                }
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                ctx.fillStyle = COLORS.SKY;
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                
                ctx.beginPath();
                ctx.strokeStyle = COLORS.GRID;
                ctx.lineWidth = 1;
                for (let x = 0; x <= SCREEN_WIDTH; x += 16) { ctx.moveTo(x, 0); ctx.lineTo(x, SCREEN_HEIGHT); }
                for (let y = 0; y <= SCREEN_HEIGHT; y += 16) { ctx.moveTo(0, y); ctx.lineTo(SCREEN_WIDTH, y); }
                ctx.stroke();

                ctx.save();
                ctx.translate(-Math.floor(camera.current.x), 0);

                decorations.current.forEach(dec => {
                    if (dec.type === 'CLOUD') drawSprite(ctx, CLOUD_SPRITE, dec.x, dec.y);
                    else if (dec.type === 'BUSH') drawSprite(ctx, BUSH_SPRITE, dec.x, dec.y);
                });

                platforms.current.forEach(plat => {
                    let sprite = GROUND_SPRITE;
                    if (plat.type === 'BRICK') sprite = BRICK_SPRITE;
                    if (plat.type === 'QBLOCK') sprite = QBLOCK_SPRITE;
                    if (plat.type === 'PIPE_BODY') sprite = PIPE_BODY_SPRITE;
                    drawTiledSprite(ctx, sprite, Math.floor(plat.x), Math.floor(plat.y), plat.w, plat.h);
                });

                const c = cake.current;
                ctx.fillStyle = COLORS.CAKE_BASE; ctx.fillRect(c.x, c.y, c.w, c.h); 
                ctx.fillStyle = COLORS.CAKE_TOP; ctx.fillRect(c.x - 2, c.y, c.w + 4, 12);
                ctx.fillStyle = 'red';
                ctx.fillRect(c.x + 10, c.y - 10, 4, 10); ctx.fillRect(c.x + 22, c.y - 10, 4, 10); ctx.fillRect(c.x + 34, c.y - 10, 4, 10);
                ctx.fillStyle = 'yellow';
                if (Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.fillRect(c.x + 10, c.y - 14, 4, 4); ctx.fillRect(c.x + 22, c.y - 14, 4, 4); ctx.fillRect(c.x + 34, c.y - 14, 4, 4);
                }

                eggs.current.forEach(egg => {
                    if (!egg.collected) {
                        const bobY = Math.sin(egg.frameOffset) * 3;
                        drawSprite(ctx, COIN_SPRITE, Math.floor(egg.x), Math.floor(egg.y + bobY));
                    }
                });

                enemies.current.forEach(e => {
                    if (e.y < SCREEN_HEIGHT) { 
                        ctx.fillStyle = COLORS.GOOMBA;
                        ctx.fillRect(Math.floor(e.x), Math.floor(e.y), e.w, e.h);
                        const walkOffset = Math.floor(Date.now() / 200) % 2 === 0 ? 0 : 1;
                        ctx.fillStyle = 'black'; 
                        ctx.fillRect(Math.floor(e.x), Math.floor(e.y) + e.h - 2, 4, 2 + walkOffset);
                        ctx.fillRect(Math.floor(e.x) + e.w - 4, Math.floor(e.y) + e.h - 2, 4, 2 - walkOffset);
                        ctx.fillStyle = 'white';
                        ctx.fillRect(Math.floor(e.x) + 2, Math.floor(e.y) + 4, 4, 4);
                        ctx.fillRect(Math.floor(e.x) + 10, Math.floor(e.y) + 4, 4, 4);
                    }
                });

                const p = yoshi.current;
                drawSprite(ctx, YOSHI_SPRITE, Math.floor(p.x), Math.floor(p.y), !p.facingRight);
                ctx.restore();

                // UI
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(5, 5, 100, 26);
                drawSprite(ctx, COIN_SPRITE, 10, 8);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px "Courier New"';
                ctx.fillText(`x ${eggCount.current} / 5`, 40, 24);

                if (gameState === 'GAMEOVER') {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    ctx.fillStyle = 'white'; ctx.textAlign = 'center';
                    ctx.font = '20px "Courier New"'; ctx.fillText("GAME OVER", SCREEN_WIDTH/2, SCREEN_HEIGHT/2);
                    ctx.font = '12px "Courier New"'; ctx.fillText("Tap Jump (A) to Retry", SCREEN_WIDTH/2, SCREEN_HEIGHT/2 + 20);
                } else if (gameState === 'WIN') {
                    ctx.fillStyle = 'rgba(255,255,255,0.2)'; 
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    ctx.fillStyle = '#d946ef'; ctx.textAlign = 'center';
                    ctx.font = '20px "Courier New"'; ctx.fillText("MISSION COMPLETE!", SCREEN_WIDTH/2, SCREEN_HEIGHT/2 - 20);
                    ctx.fillStyle = 'white';
                    ctx.font = '12px "Courier New"'; ctx.fillText(`You collected all 5 coins!`, SCREEN_WIDTH/2, SCREEN_HEIGHT/2 + 10);
                    ctx.fillText(`Tap Jump (A) to Replay`, SCREEN_WIDTH/2, SCREEN_HEIGHT/2 + 30);
                }
                ctx.textAlign = 'left';
            };

            const animate = (time) => {
                if (previousTimeRef.current !== undefined && gameState === 'PLAYING') {
                    const dt = Math.min((time - previousTimeRef.current) / 1000, 0.05);
                    update(dt);
                    draw();
                } else if (gameState !== 'PLAYING') {
                    draw();
                }
                previousTimeRef.current = time;
                requestRef.current = requestAnimationFrame(animate);
            };

            useEffect(() => {
                requestRef.current = requestAnimationFrame(animate);
                return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
            }, [gameState]);

            useEffect(() => {
                const handleReset = () => {
                    const input = inputManager.getState();
                    if (input.a && (gameState === 'GAMEOVER' || gameState === 'WIN')) {
                        loadLevel();
                    }
                }
                const interval = setInterval(handleReset, 100);
                return () => clearInterval(interval);
            }, [gameState]);

            return (
                <div className="fixed inset-0 w-full h-full bg-black flex items-center justify-center relative overflow-hidden font-retro touch-none select-none">
                    <canvas ref={canvasRef} width={SCREEN_WIDTH} height={SCREEN_HEIGHT} className="w-full h-full block" style={{ imageRendering: 'pixelated', objectFit: 'contain' }} />
                    <VirtualPad />
                    <div className="absolute top-4 right-4 text-white text-xs hidden md:block opacity-50 text-right pointer-events-none">
                        <p>ARROWS = MOVE</p>
                        <p>X / K = JUMP (Double Tap)</p>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
