<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Yoshi's Egg Defense</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #111;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }
      #root { 
          width: 100%; 
          height: 100%; 
          display: flex;
          justify-content: center;
          align-items: center;
      }
      .font-retro { font-family: 'Courier New', Courier, monospace; }
      
      canvas {
          background-color: #87CEEB; /* Sky Blue */
          image-rendering: pixelated;
          width: min(100vw, 133.33vh);
          height: min(100vh, 75vw);
          box-shadow: 0 0 20px rgba(0,0,0,0.5);
      }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- MAIN GAME SCRIPT -->
    <script type="text/babel" data-presets="typescript,react">
        const { useState, useEffect, useRef, useCallback } = React;

        // ==========================================
        // 1. CONSTANTS & CONFIG
        // ==========================================
        const SCREEN_WIDTH = 320;
        const SCREEN_HEIGHT = 240;
        const YOSHI_SPEED = 160;
        const EGG_SPEED = 250;
        const ENEMY_SPEED = 20;
        const MAX_AMMO = 6;
        const RELOAD_ZONE_WIDTH = 25;

        const COLORS = {
            SKY: '#63adff',
            RELOAD_ZONE: 'rgba(0, 100, 255, 0.3)',
            RELOAD_ZONE_ACTIVE: 'rgba(0, 100, 255, 0.6)',
            TEXT: '#ffffff',
        };

        const PAL = {
            _: null,
            W: '#ffffff', // White
            K: '#000000', // Black
            G: '#4ade80', // Yoshi Green
            R: '#ef4444', // Red
            O: '#f97316', // Orange
            Y: '#eab308', // Yellow
            B: '#3b82f6', // Blue
            S: '#78350f', // Shoe Brown
            F: '#fca5a5', // Face/Skin
        };

        // ==========================================
        // 2. ASSETS
        // ==========================================
        
        // 16x16 Yoshi
        const YOSHI_SPRITE = [
            "____GGGGG_______",
            "___GWWWWG_______",
            "___GWWWWG_______",
            "__GWWWWGGGG____",
            "__GWWGGGGGGG____",
            "__GWWGGGGGGG____",
            "__GGGGGGGGGRR___",
            "__GGGGGGGGGRR___",
            "___GGGGGGGGG____",
            "___GGGGGGGGG____",
            "__GGGGGGW_______",
            "__OGGGGGW_______",
            "__OGGGGW________",
            "__OOO___________",
            "__OOOOO_________",
            "__OO_OO_________",
        ];

        // 16x16 Shy Guy
        const SHYGUY_SPRITE = [
            "______RRRR______",
            "_____RRRRRR_____",
            "____RRRRRRRR____",
            "____RWWWWWWR____",
            "____RWKWWWKR____",
            "____RWKWWWKR____",
            "____RWWWWWWR____",
            "____RRRRRRRR____",
            "_____RRRRRR_____",
            "_____BBBBBB_____",
            "____BBBBBBBB____",
            "____BB____BB____",
            "___SSS____SSS___",
            "___SSS____SSS___",
        ];

        // 8x8 Egg
        const EGG_SPRITE = [
            "__WWWW__",
            "_WWWWWW_",
            "_WGGGGW_",
            "WGGGGGGW",
            "WWWWWWWW",
            "WWWWWWWW",
            "_WWWWWW_",
            "__WWWW__",
        ];

        // ==========================================
        // 3. AUDIO ENGINE
        // ==========================================
        class AudioEngine {
            constructor() { this.ctx = null; }
            getContext() {
                if (!this.ctx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (AC) this.ctx = new AC();
                }
                return this.ctx;
            }
            playShoot() {
                const ctx = this.getContext();
                if (!ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            }
            playReload() {
                const ctx = this.getContext();
                if (!ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.2);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.2);
            }
            playExplosion() {
                const ctx = this.getContext();
                if (!ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            }
            playWin() {
                const ctx = this.getContext();
                if (!ctx) return;
                const notes = [523, 659, 783, 1046, 783, 1046];
                notes.forEach((freq, i) => {
                    const o = ctx.createOscillator();
                    const g = ctx.createGain();
                    o.type = 'square';
                    o.frequency.value = freq;
                    g.gain.value = 0.1;
                    g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i*0.15 + 0.1);
                    o.connect(g); g.connect(ctx.destination);
                    o.start(ctx.currentTime + i*0.15); o.stop(ctx.currentTime + i*0.15 + 0.2);
                });
            }
            playEmpty() {
                const ctx = this.getContext();
                if (!ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                gain.gain.setValueAtTime(0.05, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.05);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.05);
            }
        }
        const audio = new AudioEngine();

        // ==========================================
        // 4. INPUT & CONTROLS
        // ==========================================
        const useInput = () => {
            const [input, setInput] = useState({ left: false, right: false, fire: false });
            
            useEffect(() => {
                const handleKey = (e, isDown) => {
                    switch(e.key) {
                        case 'ArrowLeft': case 'a': setInput(p => ({...p, left: isDown})); break;
                        case 'ArrowRight': case 'd': setInput(p => ({...p, right: isDown})); break;
                        case ' ': case 'z': case 'Enter': setInput(p => ({...p, fire: isDown})); break;
                    }
                };
                window.addEventListener('keydown', e => handleKey(e, true));
                window.addEventListener('keyup', e => handleKey(e, false));
                return () => {
                    window.removeEventListener('keydown', e => handleKey(e, true));
                    window.removeEventListener('keyup', e => handleKey(e, false));
                };
            }, []);
            return input;
        };

        const VirtualPad = ({ onInput }) => {
            const handleTouch = (key, active) => {
                onInput(prev => ({ ...prev, [key]: active }));
            };
            
            const btnClass = "w-16 h-16 rounded-full bg-gray-700/50 border-2 border-white/30 flex items-center justify-center active:bg-gray-500/50 select-none touch-none";

            return (
                <div className="absolute bottom-4 w-full px-8 flex justify-between pointer-events-none z-50">
                    <div className="flex gap-4 pointer-events-auto">
                        <div className={btnClass} 
                             onTouchStart={(e)=>{e.preventDefault(); handleTouch('left', true)}} 
                             onTouchEnd={(e)=>{e.preventDefault(); handleTouch('left', false)}}
                             onMouseDown={(e)=>{e.preventDefault(); handleTouch('left', true)}} 
                             onMouseUp={(e)=>{e.preventDefault(); handleTouch('left', false)}}
                        >
                            <span className="text-white text-2xl">←</span>
                        </div>
                        <div className={btnClass} 
                             onTouchStart={(e)=>{e.preventDefault(); handleTouch('right', true)}} 
                             onTouchEnd={(e)=>{e.preventDefault(); handleTouch('right', false)}}
                             onMouseDown={(e)=>{e.preventDefault(); handleTouch('right', true)}} 
                             onMouseUp={(e)=>{e.preventDefault(); handleTouch('right', false)}}
                        >
                            <span className="text-white text-2xl">→</span>
                        </div>
                    </div>
                    <div className="pointer-events-auto">
                        <div className={`${btnClass} bg-red-600/60 border-red-300`} 
                             onTouchStart={(e)=>{e.preventDefault(); handleTouch('fire', true)}} 
                             onTouchEnd={(e)=>{e.preventDefault(); handleTouch('fire', false)}}
                             onMouseDown={(e)=>{e.preventDefault(); handleTouch('fire', true)}} 
                             onMouseUp={(e)=>{e.preventDefault(); handleTouch('fire', false)}}
                        >
                            <span className="text-white font-bold">FIRE</span>
                        </div>
                    </div>
                </div>
            );
        };

        // ==========================================
        // 5. MAIN GAME LOGIC
        // ==========================================
        const App = () => {
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const prevTimeRef = useRef();
            
            // Game State
            const [gameState, setGameState] = useState('START');
            const [virtualInput, setVirtualInput] = useState({ left: false, right: false, fire: false });
            const kbInput = useInput();
            
            // Refs for game loop data
            const yoshi = useRef({ x: SCREEN_WIDTH/2, y: SCREEN_HEIGHT - 32, w: 16, h: 16, ammo: MAX_AMMO, facingRight: true });
            const bullets = useRef([]);
            const enemies = useRef([]);
            const particles = useRef([]);
            const fireCooldown = useRef(0);
            const isReloading = useRef(false);

            // Inputs
            const getInput = () => ({
                left: kbInput.left || virtualInput.left,
                right: kbInput.right || virtualInput.right,
                fire: kbInput.fire || virtualInput.fire,
            });

            const initGame = () => {
                yoshi.current = { x: SCREEN_WIDTH/2 - 8, y: SCREEN_HEIGHT - 32, w: 16, h: 16, ammo: MAX_AMMO, facingRight: true };
                bullets.current = [];
                particles.current = [];
                isReloading.current = false;
                fireCooldown.current = 0;
                
                // Spawn Grid of Shy Guys
                const rows = 3;
                const cols = 6;
                const startX = 40;
                const startY = 30;
                const gapX = 40;
                const gapY = 30;
                
                enemies.current = [];
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        enemies.current.push({
                            x: startX + c * gapX,
                            y: startY + r * gapY,
                            w: 16,
                            h: 16,
                            active: true,
                            bobOffset: Math.random() * Math.PI * 2
                        });
                    }
                }
                setGameState('PLAYING');
            };

            const spawnParticles = (x, y, color) => {
                for(let i=0; i<5; i++) {
                    particles.current.push({
                        x, y, 
                        vx: (Math.random() - 0.5) * 100, 
                        vy: (Math.random() - 0.5) * 100,
                        life: 0.5,
                        color
                    });
                }
            };

            const update = (dt) => {
                const input = getInput();
                const player = yoshi.current;

                // 1. Player Movement
                if (input.left) {
                    player.x -= YOSHI_SPEED * dt;
                    player.facingRight = false;
                }
                if (input.right) {
                    player.x += YOSHI_SPEED * dt;
                    player.facingRight = true;
                }

                // Bounds
                if (player.x < 0) player.x = 0;
                if (player.x > SCREEN_WIDTH - player.w) player.x = SCREEN_WIDTH - player.w;

                // 2. Reload Logic (Supply Zones)
                const inLeftZone = player.x < RELOAD_ZONE_WIDTH;
                const inRightZone = player.x > SCREEN_WIDTH - RELOAD_ZONE_WIDTH - player.w;
                
                if ((inLeftZone || inRightZone)) {
                    if (!isReloading.current && player.ammo < MAX_AMMO) {
                        player.ammo = MAX_AMMO;
                        isReloading.current = true;
                        audio.playReload();
                    }
                } else {
                    isReloading.current = false;
                }

                // 3. Shooting
                if (fireCooldown.current > 0) fireCooldown.current -= dt;
                
                if (input.fire && fireCooldown.current <= 0) {
                    if (player.ammo > 0) {
                        bullets.current.push({
                            x: player.x + 4,
                            y: player.y - 4,
                            w: 8,
                            h: 8,
                            active: true
                        });
                        player.ammo--;
                        fireCooldown.current = 0.25;
                        audio.playShoot();
                    } else {
                        // Empty click sound
                        fireCooldown.current = 0.2;
                        audio.playEmpty();
                    }
                }

                // 4. Update Bullets
                bullets.current.forEach(b => {
                    b.y -= EGG_SPEED * dt;
                    if (b.y < -10) b.active = false;
                });

                // 5. Update Enemies
                let activeEnemies = 0;
                let hitPlayer = false;
                
                enemies.current.forEach(e => {
                    if (!e.active) return;
                    activeEnemies++;
                    
                    // Move Down
                    e.y += ENEMY_SPEED * dt;
                    // Bobbing
                    e.bobOffset += dt * 5;
                    
                    // Check Collision with Player or Bottom
                    if (e.y + e.h > player.y + 4) { // Hit player level
                        hitPlayer = true;
                    }
                    
                    // Check Collision with Bullets
                    bullets.current.forEach(b => {
                        if (b.active && 
                            b.x < e.x + e.w && b.x + b.w > e.x &&
                            b.y < e.y + e.h && b.y + b.h > e.y) {
                            
                            b.active = false;
                            e.active = false;
                            spawnParticles(e.x + 8, e.y + 8, '#ef4444');
                            audio.playExplosion();
                        }
                    });
                });
                
                bullets.current = bullets.current.filter(b => b.active);

                // 6. Particles
                particles.current.forEach(p => {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt;
                });
                particles.current = particles.current.filter(p => p.life > 0);

                // 7. Game Over / Win Checks
                if (hitPlayer) {
                    setGameState('GAMEOVER');
                } else if (activeEnemies === 0) {
                    setGameState('WIN');
                    audio.playWin();
                }
            };

            const drawSprite = (ctx, sprite, x, y, flipX=false) => {
                const h = sprite.length;
                const w = sprite[0].length;
                ctx.save();
                if (flipX) {
                    ctx.translate(x + w, y);
                    ctx.scale(-1, 1);
                    ctx.translate(0, 0); 
                    x = 0; // Relative to transform
                } else {
                    ctx.translate(x, y);
                    x = 0;
                }
                
                for(let r=0; r<h; r++) {
                    for(let c=0; c<w; c++) {
                        const char = sprite[r][c];
                        if (PAL[char]) {
                            ctx.fillStyle = PAL[char];
                            ctx.fillRect(c, r, 1, 1);
                        }
                    }
                }
                ctx.restore();
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                // Clear
                ctx.fillStyle = COLORS.SKY;
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                // Draw Supply Zones
                ctx.fillStyle = isReloading.current ? COLORS.RELOAD_ZONE_ACTIVE : COLORS.RELOAD_ZONE;
                ctx.fillRect(0, 0, RELOAD_ZONE_WIDTH, SCREEN_HEIGHT);
                ctx.fillRect(SCREEN_WIDTH - RELOAD_ZONE_WIDTH, 0, RELOAD_ZONE_WIDTH, SCREEN_HEIGHT);
                
                // Supply Text labels
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '10px "Courier New"';
                ctx.save();
                ctx.translate(10, SCREEN_HEIGHT/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText("RELOAD", 0, 0);
                ctx.restore();
                
                ctx.save();
                ctx.translate(SCREEN_WIDTH - 5, SCREEN_HEIGHT/2);
                ctx.rotate(Math.PI/2);
                ctx.fillText("RELOAD", 0, 0);
                ctx.restore();

                // Draw Ground
                ctx.fillStyle = '#166534'; // Dark Green
                ctx.fillRect(0, SCREEN_HEIGHT - 16, SCREEN_WIDTH, 16);
                ctx.fillStyle = '#22c55e'; // Light Green
                ctx.fillRect(0, SCREEN_HEIGHT - 16, SCREEN_WIDTH, 4);

                // Draw Player
                const p = yoshi.current;
                drawSprite(ctx, YOSHI_SPRITE, Math.floor(p.x), Math.floor(p.y), !p.facingRight);

                // Draw Enemies
                enemies.current.forEach(e => {
                    if (e.active) {
                        const bobY = Math.sin(e.bobOffset) * 2;
                        drawSprite(ctx, SHYGUY_SPRITE, Math.floor(e.x), Math.floor(e.y + bobY));
                    }
                });

                // Draw Bullets
                bullets.current.forEach(b => {
                    drawSprite(ctx, EGG_SPRITE, Math.floor(b.x), Math.floor(b.y));
                });

                // Draw Particles
                particles.current.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 0.5;
                    ctx.fillRect(p.x, p.y, 2, 2);
                    ctx.globalAlpha = 1;
                });

                // UI: Ammo
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(5, 5, 80, 20);
                for(let i=0; i<MAX_AMMO; i++) {
                    ctx.fillStyle = i < p.ammo ? '#ffffff' : '#555555';
                    ctx.beginPath();
                    ctx.arc(15 + i * 10, 15, 3, 0, Math.PI*2);
                    ctx.fill();
                }

                // Overlays
                if (gameState !== 'PLAYING') {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    
                    if (gameState === 'START') {
                        ctx.font = 'bold 20px "Courier New"';
                        ctx.fillStyle = '#4ade80';
                        ctx.fillText("YOSHI'S EGG DEFENSE", SCREEN_WIDTH/2, 100);
                        ctx.font = '12px "Courier New"';
                        ctx.fillStyle = '#fff';
                        ctx.fillText("Shoot the Shy Guys!", SCREEN_WIDTH/2, 130);
                        ctx.fillText("Run to sides to RELOAD", SCREEN_WIDTH/2, 150);
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillText("Press FIRE to Start", SCREEN_WIDTH/2, 180);
                    } else if (gameState === 'GAMEOVER') {
                        ctx.font = 'bold 24px "Courier New"';
                        ctx.fillStyle = '#ef4444';
                        ctx.fillText("GAME OVER", SCREEN_WIDTH/2, 110);
                        ctx.font = '12px "Courier New"';
                        ctx.fillStyle = '#fff';
                        ctx.fillText("Press FIRE to Retry", SCREEN_WIDTH/2, 140);
                    } else if (gameState === 'WIN') {
                        ctx.font = 'bold 24px "Courier New"';
                        ctx.fillStyle = '#d946ef'; // Pink
                        ctx.fillText("アタン～", SCREEN_WIDTH/2, 100);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText("超すごい～！", SCREEN_WIDTH/2, 130);
                        
                        ctx.font = '12px "Courier New"';
                        ctx.fillStyle = '#fbbf24';
                        ctx.fillText("Press FIRE to Play Again", SCREEN_WIDTH/2, 160);
                    }
                }
            };

            const loop = (time) => {
                if (prevTimeRef.current !== undefined) {
                    const dt = Math.min((time - prevTimeRef.current) / 1000, 0.05);
                    if (gameState === 'PLAYING') update(dt);
                    draw();
                }
                prevTimeRef.current = time;
                requestRef.current = requestAnimationFrame(loop);
            };

            useEffect(() => {
                requestRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(requestRef.current);
            }, [gameState]); // Re-bind if state changes (mostly for pause effect logic if needed)

            // Start Input Handler
            useEffect(() => {
                const input = getInput();
                if (input.fire && (gameState === 'START' || gameState === 'GAMEOVER' || gameState === 'WIN')) {
                    // Simple debounce
                    if (!isReloading.current) { // misuse variable for debounce flag briefly
                         initGame();
                         isReloading.current = true; // prevent double trigger
                         setTimeout(() => isReloading.current = false, 500);
                    }
                }
            }, [virtualInput, kbInput]);

            return (
                <div className="relative w-full h-full flex items-center justify-center">
                    <canvas ref={canvasRef} width={SCREEN_WIDTH} height={SCREEN_HEIGHT} />
                    <VirtualPad onInput={setVirtualInput} />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>