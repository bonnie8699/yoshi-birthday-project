<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Yoshi's Egg Defense: Volcano Edition</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }
      #root { 
          width: 100%; 
          height: 100%; 
          display: flex;
          justify-content: center;
          align-items: center;
      }
      
      canvas {
          background-color: #2d1010;
          image-rendering: pixelated;
          width: 100vw;
          height: 100vh;
          object-fit: contain;
      }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <!-- MAIN GAME SCRIPT -->
    <script type="text/babel" data-presets="typescript,react">
        const { useState, useEffect, useRef, useCallback } = React;

        // ==========================================
        // 1. CONSTANTS & CONFIG
        // ==========================================
        const SCREEN_WIDTH = 320;
        const SCREEN_HEIGHT = 240;
        const YOSHI_SPEED = 160;
        const EGG_SPEED = 250;
        const ENEMY_SPEED = 10; // Slightly slower for better feel
        const MAX_AMMO = 6;
        const RELOAD_ZONE_WIDTH = 25;

        const COLORS = {
            SKY: '#2d1010', // Dark Volcanic Sky
            LAVA: '#ff4d00',
            LAVA_GLOW: '#ffcc00',
            RELOAD_ZONE: 'rgba(0, 150, 255, 0.2)',
            RELOAD_ZONE_ACTIVE: 'rgba(0, 200, 255, 0.5)',
            TEXT: '#ffffff',
        };

        const PAL = {
            _: null,
            W: '#ffffff', // White
            K: '#000000', // Black
            G: '#4ade80', // Yoshi Green
            R: '#ef4444', // Red
            O: '#f97316', // Orange
            Y: '#eab308', // Yellow
            B: '#3b82f6', // Blue
            S: '#4a3728', // Rock Brown
            F: '#fca5a5', // Face
            L: '#ff4d00', // Lava
            V: '#1a0d0d', // Deep Volcano Shadow
            C: '#d946ef', // Magic Pink
        };

        // ==========================================
        // 2. ASSETS
        // ==========================================
        
        const YOSHI_SPRITE = [
            "____GGGGG_______",
            "___GWWWWG_______",
            "___GWWWWG_______",
            "__GWWWWGGGG____",
            "__GWWGGGGGGG____",
            "__GWWGGGGGGG____",
            "__GGGGGGGGGRR___",
            "__GGGGGGGGGRR___",
            "___GGGGGGGGG____",
            "___GGGGGGGGG____",
            "__GGGGGGW_______",
            "__OGGGGGW_______",
            "__OGGGGW________",
            "__OOO___________",
            "__OOOOO_________",
            "__OO_OO_________",
        ];

        const SHYGUY_SPRITE = [
            "______RRRR______",
            "_____RRRRRR_____",
            "____RRRRRRRR____",
            "____RWWWWWWR____",
            "____RWKWWWKR____",
            "____RWKWWWKR____",
            "____RWWWWWWR____",
            "____RRRRRRRR____",
            "_____RRRRRR_____",
            "_____BBBBBB_____",
            "____BBBBBBBB____",
            "____BB____BB____",
            "___SSS____SSS___",
            "___SSS____SSS___",
        ];

        const EGG_SPRITE = [
            "__WWWW__",
            "_WWWWWW_",
            "_WGGGGW_",
            "WGGGGGGW",
            "WWWWWWWW",
            "WWWWWWWW",
            "_WWWWWW_",
            "__WWWW__",
        ];

        const VOLCANO_SPRITE = [
            "_________LL_________ ",
            "________LLLL________",
            "_______LLLLLL_______",
            "______LLLLLLLL______",
            "_____VVVVVVVVVV_____",
            "____VVVVVVVVVVVV____",
            "___VVVVVVVVVVVVVV___",
            "__VVVVVVVVVVVVVVVV__",
            "_VVVVVVVVVVVVVVVVVV_",
            "VVVVVVVVVVVVVVVVVVVV"
        ];

        // ==========================================
        // 3. AUDIO ENGINE
        // ==========================================
        class AudioEngine {
            constructor() { this.ctx = null; }
            getContext() {
                if (!this.ctx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (AC) this.ctx = new AC();
                }
                return this.ctx;
            }
            playShoot() {
                const ctx = this.getContext();
                if (!ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            }
            playReload() {
                const ctx = this.getContext();
                if (!ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.2);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.2);
            }
            playExplosion() {
                const ctx = this.getContext();
                if (!ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            }
            playWin() {
                const ctx = this.getContext();
                if (!ctx) return;
                const notes = [523, 659, 783, 1046, 783, 1046];
                notes.forEach((freq, i) => {
                    const o = ctx.createOscillator();
                    const g = ctx.createGain();
                    o.type = 'square';
                    o.frequency.value = freq;
                    g.gain.value = 0.1;
                    g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i*0.15 + 0.1);
                    o.connect(g); g.connect(ctx.destination);
                    o.start(ctx.currentTime + i*0.15); o.stop(ctx.currentTime + i*0.15 + 0.2);
                });
            }
            playEmpty() {
                const ctx = this.getContext();
                if (!ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                gain.gain.setValueAtTime(0.05, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.05);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.05);
            }
        }
        const audio = new AudioEngine();

        // ==========================================
        // 4. COMPONENTS
        // ==========================================
        const VirtualPad = ({ setInput }) => {
            const handleTouch = (key, active) => { setInput(key, active); };
            const btnClass = "w-16 h-16 rounded-full bg-gray-700/50 border-2 border-white/30 flex items-center justify-center active:bg-gray-500/70 select-none touch-none";
            return (
                <div className="absolute bottom-4 w-full px-8 flex justify-between pointer-events-none z-50">
                    <div className="flex gap-4 pointer-events-auto">
                        <div className={btnClass} onPointerDown={()=>handleTouch('left', true)} onPointerUp={()=>handleTouch('left', false)} onPointerLeave={()=>handleTouch('left', false)}>
                            <span className="text-white text-2xl">←</span>
                        </div>
                        <div className={btnClass} onPointerDown={()=>handleTouch('right', true)} onPointerUp={()=>handleTouch('right', false)} onPointerLeave={()=>handleTouch('right', false)}>
                            <span className="text-white text-2xl">→</span>
                        </div>
                    </div>
                    <div className="pointer-events-auto">
                        <div className={`${btnClass} bg-red-600/60 border-red-300`} onPointerDown={()=>handleTouch('fire', true)} onPointerUp={()=>handleTouch('fire', false)} onPointerLeave={()=>handleTouch('fire', false)}>
                            <span className="text-white font-bold">FIRE</span>
                        </div>
                    </div>
                </div>
            );
        };

        // ==========================================
        // 5. MAIN GAME LOGIC
        // ==========================================
        const App = () => {
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const prevTimeRef = useRef();
            
            const [gameState, setGameState] = useState('START');
            const inputRef = useRef({ left: false, right: false, fire: false });

            const yoshi = useRef({ x: SCREEN_WIDTH/2, y: SCREEN_HEIGHT - 32, w: 16, h: 16, ammo: MAX_AMMO, facingRight: true });
            const bullets = useRef([]);
            const enemies = useRef([]);
            const particles = useRef([]);
            const fireCooldown = useRef(0);
            const isReloading = useRef(false);
            const restartDebounce = useRef(0);
            const timeRef = useRef(0);

            // -- Input Handling --
            useEffect(() => {
                const handleKey = (e, isDown) => {
                    if (gameState !== 'PLAYING' && isDown) { attemptRestart(); return; }
                    if (e.repeat) return;
                    switch(e.key) {
                        case 'ArrowLeft': case 'a': inputRef.current.left = isDown; break;
                        case 'ArrowRight': case 'd': inputRef.current.right = isDown; break;
                        case ' ': case 'z': case 'Enter': inputRef.current.fire = isDown; break;
                    }
                };
                window.addEventListener('keydown', e => handleKey(e, true));
                window.addEventListener('keyup', e => handleKey(e, false));
                return () => {
                    window.removeEventListener('keydown', e => handleKey(e, true));
                    window.removeEventListener('keyup', e => handleKey(e, false));
                };
            }, [gameState]);

            const setVirtualInput = useCallback((key, active) => {
                inputRef.current[key] = active;
                if (gameState !== 'PLAYING' && active) attemptRestart();
            }, [gameState]);

            const attemptRestart = () => {
                const now = Date.now();
                if (now - restartDebounce.current > 300) {
                    if (gameState !== 'PLAYING') { initGame(); restartDebounce.current = now; }
                }
            };

            const initGame = () => {
                yoshi.current = { x: SCREEN_WIDTH/2 - 8, y: SCREEN_HEIGHT - 32, w: 16, h: 16, ammo: MAX_AMMO, facingRight: true };
                bullets.current = [];
                particles.current = [];
                isReloading.current = false;
                fireCooldown.current = 0;
                
                // Spawning 2 rows of Shy Guys
                const rows = 2;
                const cols = 6;
                const startX = 40;
                const startY = 30;
                const gapX = 40;
                const gapY = 30;
                
                enemies.current = [];
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        enemies.current.push({
                            x: startX + c * gapX,
                            y: startY + r * gapY,
                            w: 16,
                            h: 16,
                            active: true,
                            bobOffset: Math.random() * Math.PI * 2
                        });
                    }
                }
                setGameState('PLAYING');
            };

            const spawnParticles = (x, y, color) => {
                for(let i=0; i<5; i++) {
                    particles.current.push({ x, y, vx: (Math.random() - 0.5) * 100, vy: (Math.random() - 0.5) * 100, life: 0.5, color });
                }
            };

            const update = (dt) => {
                const input = inputRef.current;
                const player = yoshi.current;
                timeRef.current += dt;

                if (input.left) { player.x -= YOSHI_SPEED * dt; player.facingRight = false; }
                if (input.right) { player.x += YOSHI_SPEED * dt; player.facingRight = true; }

                if (player.x < 0) player.x = 0;
                if (player.x > SCREEN_WIDTH - player.w) player.x = SCREEN_WIDTH - player.w;

                const inLeftZone = player.x < RELOAD_ZONE_WIDTH;
                const inRightZone = player.x > SCREEN_WIDTH - RELOAD_ZONE_WIDTH - player.w;
                
                if ((inLeftZone || inRightZone)) {
                    if (!isReloading.current && player.ammo < MAX_AMMO) {
                        player.ammo = MAX_AMMO;
                        isReloading.current = true;
                        audio.playReload();
                    }
                } else { isReloading.current = false; }

                if (fireCooldown.current > 0) fireCooldown.current -= dt;
                
                if (input.fire && fireCooldown.current <= 0) {
                    if (player.ammo > 0) {
                        bullets.current.push({ x: player.x + 4, y: player.y - 4, w: 8, h: 8, active: true });
                        player.ammo--;
                        fireCooldown.current = 0.25;
                        audio.playShoot();
                    } else { fireCooldown.current = 0.2; audio.playEmpty(); }
                }

                bullets.current.forEach(b => {
                    b.y -= EGG_SPEED * dt;
                    if (b.y < -10) b.active = false;
                });

                let activeEnemies = 0;
                let hitPlayer = false;
                
                enemies.current.forEach(e => {
                    if (!e.active) return;
                    activeEnemies++;
                    e.y += ENEMY_SPEED * dt;
                    e.bobOffset += dt * 5;
                    
                    if (e.y + e.h > player.y + 4) hitPlayer = true;
                    
                    bullets.current.forEach(b => {
                        if (b.active && b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
                            b.active = false; e.active = false;
                            spawnParticles(e.x + 8, e.y + 8, '#ffcc00');
                            audio.playExplosion();
                        }
                    });
                });
                
                bullets.current = bullets.current.filter(b => b.active);

                particles.current.forEach(p => {
                    p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
                });
                particles.current = particles.current.filter(p => p.life > 0);

                if (hitPlayer) setGameState('GAMEOVER');
                else if (activeEnemies === 0) { setGameState('WIN'); audio.playWin(); }
            };

            const drawSprite = (ctx, sprite, x, y, flipX=false, scale=1) => {
                const h = sprite.length;
                const w = sprite[0].length;
                ctx.save();
                ctx.translate(x, y);
                if (flipX) { ctx.scale(-1, 1); ctx.translate(-w * scale, 0); }
                ctx.scale(scale, scale);
                for(let r=0; r<h; r++) {
                    for(let c=0; c<w; c++) {
                        const char = sprite[r][c];
                        if (PAL[char]) {
                            ctx.fillStyle = PAL[char];
                            ctx.fillRect(c, r, 1, 1);
                        }
                    }
                }
                ctx.restore();
            };

            const drawBackground = (ctx) => {
                // Sky
                const grad = ctx.createLinearGradient(0, 0, 0, SCREEN_HEIGHT);
                grad.addColorStop(0, '#1a0505');
                grad.addColorStop(0.5, '#4b150c');
                grad.addColorStop(1, '#8b230f');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                // Distant Volcanoes
                drawSprite(ctx, VOLCANO_SPRITE, 40, 100, false, 4);
                drawSprite(ctx, VOLCANO_SPRITE, 180, 110, true, 3);
                
                // Lava at the very bottom
                const lavaPulse = Math.sin(timeRef.current * 3) * 5;
                ctx.fillStyle = '#ff4d00';
                ctx.fillRect(0, SCREEN_HEIGHT - 12 + lavaPulse, SCREEN_WIDTH, 12);
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(0, SCREEN_HEIGHT - 12 + lavaPulse, SCREEN_WIDTH, 2);

                // Ground (Rocky Cliff)
                ctx.fillStyle = '#2d1b11'; // Dark brown rock
                ctx.fillRect(0, SCREEN_HEIGHT - 16, SCREEN_WIDTH, 16);
                ctx.fillStyle = '#1a0d0d'; // Deep shadow
                ctx.fillRect(0, SCREEN_HEIGHT - 16, SCREEN_WIDTH, 2);
                
                // Cracks in rock
                ctx.fillStyle = '#4b150c';
                for(let i=0; i<SCREEN_WIDTH; i+=20) {
                    ctx.fillRect(i + (Math.sin(i)*5), SCREEN_HEIGHT - 14, 2, 8);
                }
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                drawBackground(ctx);

                // Supply Zones (Glowing blue to contrast with fire)
                ctx.fillStyle = isReloading.current ? COLORS.RELOAD_ZONE_ACTIVE : COLORS.RELOAD_ZONE;
                ctx.fillRect(0, 0, RELOAD_ZONE_WIDTH, SCREEN_HEIGHT);
                ctx.fillRect(SCREEN_WIDTH - RELOAD_ZONE_WIDTH, 0, RELOAD_ZONE_WIDTH, SCREEN_HEIGHT);
                
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = '10px "Courier New"';
                ctx.save();
                ctx.translate(10, SCREEN_HEIGHT/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText("RELOAD", 0, 0);
                ctx.restore();
                ctx.save();
                ctx.translate(SCREEN_WIDTH - 5, SCREEN_HEIGHT/2);
                ctx.rotate(Math.PI/2);
                ctx.fillText("RELOAD", 0, 0);
                ctx.restore();

                const p = yoshi.current;
                drawSprite(ctx, YOSHI_SPRITE, Math.floor(p.x), Math.floor(p.y), !p.facingRight);

                enemies.current.forEach(e => {
                    if (e.active) {
                        const bobY = Math.sin(e.bobOffset) * 2;
                        drawSprite(ctx, SHYGUY_SPRITE, Math.floor(e.x), Math.floor(e.y + bobY));
                    }
                });

                bullets.current.forEach(b => {
                    drawSprite(ctx, EGG_SPRITE, Math.floor(b.x), Math.floor(b.y));
                });

                particles.current.forEach(pt => {
                    ctx.fillStyle = pt.color;
                    ctx.globalAlpha = pt.life / 0.5;
                    ctx.fillRect(pt.x, pt.y, 2, 2);
                    ctx.globalAlpha = 1;
                });

                // UI
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(5, 5, 80, 20);
                for(let i=0; i<MAX_AMMO; i++) {
                    ctx.fillStyle = i < p.ammo ? '#ffffff' : '#444444';
                    ctx.beginPath(); ctx.arc(15 + i * 10, 15, 3, 0, Math.PI*2); ctx.fill();
                }

                if (gameState !== 'PLAYING') {
                    ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    
                    if (gameState === 'START') {
                        ctx.font = 'bold 20px "Courier New"';
                        ctx.fillStyle = '#ff4d00';
                        ctx.fillText("YOSHI'S VOLCANO DEFENSE", SCREEN_WIDTH/2, 100);
                        ctx.font = '12px "Courier New"';
                        ctx.fillStyle = '#fff';
                        ctx.fillText("Shoot the Shy Guys!", SCREEN_WIDTH/2, 130);
                        ctx.fillText("Reload at the BLUE EDGES", SCREEN_WIDTH/2, 150);
                        ctx.fillStyle = '#ffcc00';
                        ctx.fillText("Tap anywhere to Start", SCREEN_WIDTH/2, 180);
                    } else if (gameState === 'GAMEOVER') {
                        ctx.font = 'bold 24px "Courier New"';
                        ctx.fillStyle = '#ef4444';
                        ctx.fillText("GAME OVER", SCREEN_WIDTH/2, 110);
                        ctx.font = '12px "Courier New"';
                        ctx.fillStyle = '#fff';
                        ctx.fillText("Tap anywhere to Retry", SCREEN_WIDTH/2, 140);
                    } else if (gameState === 'WIN') {
                        ctx.font = 'bold 24px "Courier New"';
                        ctx.fillStyle = '#d946ef';
                        ctx.fillText("アタン～", SCREEN_WIDTH/2, 100);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText("超すごい～！", SCREEN_WIDTH/2, 130);
                        ctx.font = '12px "Courier New"';
                        ctx.fillStyle = '#ffcc00';
                        ctx.fillText("Tap anywhere to Play Again", SCREEN_WIDTH/2, 160);
                    }
                }
            };

            const loop = (time) => {
                if (prevTimeRef.current !== undefined) {
                    const dt = Math.min((time - prevTimeRef.current) / 1000, 0.05);
                    if (gameState === 'PLAYING') update(dt);
                    draw();
                }
                prevTimeRef.current = time;
                requestRef.current = requestAnimationFrame(loop);
            };

            useEffect(() => {
                requestRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(requestRef.current);
            }, [gameState]);

            return (
                <div className="relative w-full h-full flex items-center justify-center bg-black" onPointerDown={attemptRestart}>
                    <canvas ref={canvasRef} width={SCREEN_WIDTH} height={SCREEN_HEIGHT} />
                    <VirtualPad setInput={setVirtualInput} />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
